<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/controller/UserController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/controller/UserController.java" />
              <option name="originalContent" value="package controller;&#10;&#10;import business.UserBusiness;&#10;import entity.User;&#10;&#10;public class UserController {&#10;    public User createUser(String name, String email, String password, String confirmPassword, String document) throws Exception {&#10;        return UserBusiness.createUser(name, email, password, confirmPassword, document);&#10;    }&#10;&#10;    public User login(String email, String password) throws Exception {&#10;        return UserBusiness.login(email, password);&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package controller;&#10;&#10;import business.UserBusiness;&#10;import entity.User;&#10;&#10;public class UserController {&#10;    private UserBusiness userBusiness;&#10;&#10;    public UserController(UserBusiness userBusiness) {&#10;        this.userBusiness = userBusiness;&#10;    }&#10;&#10;    public User createUser(String name, String email, String password, String confirmPassword, String document) throws Exception {&#10;        return userBusiness.createUser(name, email, password, confirmPassword, document);&#10;    }&#10;&#10;    public User login(String email, String password) throws Exception {&#10;        return userBusiness.login(email, password);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/controller/OrderHttpController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/controller/OrderHttpController.java" />
              <option name="originalContent" value="package controller;&#10;&#10;import business.OrderBusiness;&#10;import entity.Order;&#10;import entity.OrderItems;&#10;import dto.OrderItemsDTO;&#10;import dto.AddressDTO;&#10;import io.javalin.http.Context;&#10;import com.fasterxml.jackson.databind.JsonNode;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;&#10;import java.util.List;&#10;import java.util.ArrayList;&#10;&#10;public class OrderHttpController {&#10;    private OrderBusiness orderBusiness;&#10;    private ObjectMapper objectMapper;&#10;&#10;    public OrderHttpController(OrderBusiness orderBusiness) {&#10;        this.orderBusiness = orderBusiness;&#10;        this.objectMapper = new ObjectMapper();&#10;    }&#10;&#10;    // CREATE - POST /orders&#10;    public void createOrder(Context ctx) {&#10;        try {&#10;            System.out.println(&quot;[CONTROLLER] Starting order creation request&quot;);&#10;            JsonNode json = objectMapper.readTree(ctx.body());&#10;            Integer userId = ctx.attribute(&quot;userId&quot;); // From authentication middleware&#10;&#10;            if (userId == null) {&#10;                ctx.status(401).json(new ErrorResponse(&quot;Usuário não autenticado&quot;));&#10;                return;&#10;            }&#10;            System.out.println(&quot;[CONTROLLER] User ID from token: &quot; + userId);&#10;&#10;            // Parse address (either new address data or existing address ID)&#10;            AddressDTO addressDTO = null;&#10;            Integer existingAddressId = null;&#10;&#10;            if (json.has(&quot;addressId&quot;) &amp;&amp; !json.get(&quot;addressId&quot;).isNull()) {&#10;                existingAddressId = json.get(&quot;addressId&quot;).asInt();&#10;                System.out.println(&quot;[CONTROLLER] Using existing address ID: &quot; + existingAddressId);&#10;            } else if (json.has(&quot;address&quot;)) {&#10;                JsonNode addressNode = json.get(&quot;address&quot;);&#10;                if (addressNode.get(&quot;street&quot;) == null || addressNode.get(&quot;number&quot;) == null ||&#10;                    addressNode.get(&quot;neighborhood&quot;) == null || addressNode.get(&quot;zipCode&quot;) == null ||&#10;                    addressNode.get(&quot;city&quot;) == null || addressNode.get(&quot;state&quot;) == null) {&#10;                    ctx.status(400).json(new ErrorResponse(&quot;Campos obrigatórios do endereço: street, number, neighborhood, zipCode, city, state&quot;));&#10;                    return;&#10;                }&#10;                addressDTO = new AddressDTO(&#10;                    addressNode.get(&quot;street&quot;).asText(),&#10;                    addressNode.get(&quot;number&quot;).asText(),&#10;                    addressNode.get(&quot;neighborhood&quot;).asText(),&#10;                    addressNode.get(&quot;zipCode&quot;).asText(),&#10;                    addressNode.has(&quot;complement&quot;) ? addressNode.get(&quot;complement&quot;).asText() : &quot;&quot;,&#10;                    addressNode.get(&quot;city&quot;).asText(),&#10;                    addressNode.get(&quot;state&quot;).asText()&#10;                );&#10;                System.out.println(&quot;[CONTROLLER] Creating new address&quot;);&#10;            } else {&#10;                ctx.status(400).json(new ErrorResponse(&quot;É necessário fornecer 'addressId' ou dados completos do 'address'&quot;));&#10;                return;&#10;            }&#10;&#10;            // Parse order items&#10;            if (!json.has(&quot;items&quot;) || !json.get(&quot;items&quot;).isArray()) {&#10;                ctx.status(400).json(new ErrorResponse(&quot;Campo 'items' é obrigatório e deve ser um array&quot;));&#10;                return;&#10;            }&#10;&#10;            List&lt;OrderItemsDTO&gt; orderItems = new ArrayList&lt;&gt;();&#10;            for (JsonNode itemNode : json.get(&quot;items&quot;)) {&#10;                if (itemNode.get(&quot;productId&quot;) == null || itemNode.get(&quot;amount&quot;) == null) {&#10;                    ctx.status(400).json(new ErrorResponse(&quot;Cada item deve conter: productId, amount&quot;));&#10;                    return;&#10;                }&#10;&#10;                OrderItemsDTO item = new OrderItemsDTO(&#10;                    itemNode.get(&quot;productId&quot;).asInt(),&#10;                    itemNode.get(&quot;amount&quot;).asInt()&#10;                );&#10;                orderItems.add(item);&#10;            }&#10;            System.out.println(&quot;[CONTROLLER] Parsed &quot; + orderItems.size() + &quot; order items&quot;);&#10;&#10;            // Create order&#10;            System.out.println(&quot;[CONTROLLER] Calling business layer to create order&quot;);&#10;            Order order = orderBusiness.createOrder(userId, addressDTO, existingAddressId, orderItems);&#10;            System.out.println(&quot;[CONTROLLER] Order created with ID: &quot; + order.getId());&#10;&#10;            // Get order items to include in response&#10;            System.out.println(&quot;[CONTROLLER] Getting order items for response&quot;);&#10;            List&lt;OrderItems&gt; createdItems = orderBusiness.getOrderItems(order.getId());&#10;            System.out.println(&quot;[CONTROLLER] Found &quot; + createdItems.size() + &quot; created items&quot;);&#10;&#10;            System.out.println(&quot;[CONTROLLER] Calculating order total&quot;);&#10;            double totalValue = orderBusiness.calculateOrderTotal(order.getId());&#10;            System.out.println(&quot;[CONTROLLER] Total calculated: &quot; + totalValue);&#10;&#10;            OrderResponse response = new OrderResponse(order, createdItems, totalValue);&#10;            ctx.status(201).json(response);&#10;            System.out.println(&quot;[CONTROLLER] Order creation completed successfully&quot;);&#10;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;[CONTROLLER] Error creating order: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;            ctx.status(400).json(new ErrorResponse(&quot;Erro ao criar pedido: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // UPDATE - PUT /orders/{id}&#10;    public void updateOrder(Context ctx) {&#10;        try {&#10;            int orderId = Integer.parseInt(ctx.pathParam(&quot;id&quot;));&#10;            JsonNode json = objectMapper.readTree(ctx.body());&#10;&#10;            String orderStatus = json.has(&quot;orderStatus&quot;) ? json.get(&quot;orderStatus&quot;).asText() : null;&#10;&#10;            // For backward compatibility, still accept old status fields but ignore them&#10;            if (json.has(&quot;paymentStatus&quot;) || json.has(&quot;shippingStatus&quot;)) {&#10;                System.out.println(&quot;[ORDER_CONTROLLER] Warning: paymentStatus and shippingStatus are deprecated, use orderStatus only&quot;);&#10;            }&#10;&#10;            Order updatedOrder = orderBusiness.updateOrderStatus(orderId, orderStatus);&#10;&#10;            List&lt;OrderItems&gt; orderItems = orderBusiness.getOrderItems(orderId);&#10;            double totalValue = orderBusiness.calculateOrderTotal(orderId);&#10;&#10;            OrderResponse response = new OrderResponse(updatedOrder, orderItems, totalValue);&#10;            ctx.json(response);&#10;&#10;        } catch (NumberFormatException e) {&#10;            ctx.status(400).json(new ErrorResponse(&quot;ID do pedido inválido&quot;));&#10;        } catch (Exception e) {&#10;            ctx.status(400).json(new ErrorResponse(&quot;Erro ao atualizar pedido: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // LIST BY USER - GET /orders (uses authenticated user)&#10;    public void listOrdersByUser(Context ctx) {&#10;        try {&#10;            Integer userId = ctx.attribute(&quot;userId&quot;); // From authentication middleware&#10;&#10;            List&lt;Order&gt; orders = orderBusiness.getOrdersByUserId(userId);&#10;            List&lt;OrderSummary&gt; orderSummaries = new ArrayList&lt;&gt;();&#10;&#10;            for (Order order : orders) {&#10;                List&lt;OrderItems&gt; items = orderBusiness.getOrderItems(order.getId());&#10;                double totalValue = orderBusiness.calculateOrderTotal(order.getId());&#10;                orderSummaries.add(new OrderSummary(order, items.size(), totalValue));&#10;            }&#10;&#10;            ctx.json(orderSummaries);&#10;&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(new ErrorResponse(&quot;Erro ao buscar pedidos: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // LIST BY USER ID - GET /users/{userId}/orders (for admin or user accessing their own orders)&#10;    public void listOrdersByUserId(Context ctx) {&#10;        try {&#10;            Integer currentUserId = ctx.attribute(&quot;userId&quot;); // From authentication middleware&#10;            int requestedUserId = Integer.parseInt(ctx.pathParam(&quot;userId&quot;));&#10;&#10;            // Simple authorization - users can only see their own orders&#10;            if (!currentUserId.equals(requestedUserId)) {&#10;                ctx.status(403).json(new ErrorResponse(&quot;Acesso negado&quot;));&#10;                return;&#10;            }&#10;&#10;            List&lt;Order&gt; orders = orderBusiness.getOrdersByUserId(requestedUserId);&#10;            List&lt;OrderSummary&gt; orderSummaries = new ArrayList&lt;&gt;();&#10;&#10;            for (Order order : orders) {&#10;                List&lt;OrderItems&gt; items = orderBusiness.getOrderItems(order.getId());&#10;                double totalValue = orderBusiness.calculateOrderTotal(order.getId());&#10;                orderSummaries.add(new OrderSummary(order, items.size(), totalValue));&#10;            }&#10;&#10;            ctx.json(orderSummaries);&#10;&#10;        } catch (NumberFormatException e) {&#10;            ctx.status(400).json(new ErrorResponse(&quot;ID do usuário inválido&quot;));&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(new ErrorResponse(&quot;Erro ao buscar pedidos: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // CANCEL - DELETE /orders/{id}&#10;    public void cancelOrder(Context ctx) {&#10;        try {&#10;            int orderId = Integer.parseInt(ctx.pathParam(&quot;id&quot;));&#10;            Integer userId = ctx.attribute(&quot;userId&quot;); // From authentication middleware&#10;&#10;            // Verify order belongs to user&#10;            Order order = orderBusiness.getOrderById(orderId);&#10;            if (order == null) {&#10;                ctx.status(404).json(new ErrorResponse(&quot;Pedido não encontrado&quot;));&#10;                return;&#10;            }&#10;&#10;            if (!userId.equals(order.getUser().getId())) {&#10;                ctx.status(403).json(new ErrorResponse(&quot;Acesso negado&quot;));&#10;                return;&#10;            }&#10;&#10;            orderBusiness.cancelOrder(orderId);&#10;            ctx.json(new SuccessResponse(&quot;Pedido cancelado com sucesso&quot;));&#10;&#10;        } catch (NumberFormatException e) {&#10;            ctx.status(400).json(new ErrorResponse(&quot;ID do pedido inválido&quot;));&#10;        } catch (Exception e) {&#10;            ctx.status(400).json(new ErrorResponse(&quot;Erro ao cancelar pedido: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // GET ORDER BY ID - GET /orders/{id}&#10;    public void getOrderById(Context ctx) {&#10;        try {&#10;            int orderId = Integer.parseInt(ctx.pathParam(&quot;id&quot;));&#10;            Integer userId = ctx.attribute(&quot;userId&quot;); // From authentication middleware&#10;&#10;            Order order = orderBusiness.getOrderById(orderId);&#10;            if (order == null) {&#10;                ctx.status(404).json(new ErrorResponse(&quot;Pedido não encontrado&quot;));&#10;                return;&#10;            }&#10;&#10;            // Verify order belongs to user&#10;            if (!userId.equals(order.getUser().getId())) {&#10;                ctx.status(403).json(new ErrorResponse(&quot;Acesso negado&quot;));&#10;                return;&#10;            }&#10;&#10;            List&lt;OrderItems&gt; orderItems = orderBusiness.getOrderItems(orderId);&#10;            double totalValue = orderBusiness.calculateOrderTotal(orderId);&#10;&#10;            OrderResponse response = new OrderResponse(order, orderItems, totalValue);&#10;            ctx.json(response);&#10;&#10;        } catch (NumberFormatException e) {&#10;            ctx.status(400).json(new ErrorResponse(&quot;ID do pedido inválido&quot;));&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(new ErrorResponse(&quot;Erro ao buscar pedido: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    // Response classes&#10;    private static class ErrorResponse {&#10;        public String message;&#10;        public ErrorResponse(String message) {&#10;            this.message = message;&#10;        }&#10;    }&#10;&#10;    private static class SuccessResponse {&#10;        public String message;&#10;        public SuccessResponse(String message) {&#10;            this.message = message;&#10;        }&#10;    }&#10;&#10;    private static class OrderResponse {&#10;        public Order order;&#10;        public List&lt;OrderItems&gt; items;&#10;        public double totalValue;&#10;        public OrderResponse(Order order, List&lt;OrderItems&gt; items, double totalValue) {&#10;            this.order = order;&#10;            this.items = items;&#10;            this.totalValue = totalValue;&#10;        }&#10;    }&#10;&#10;    private static class OrderSummary {&#10;        public Order order;&#10;        public int itemCount;&#10;        public double totalValue;&#10;        public OrderSummary(Order order, int itemCount, double totalValue) {&#10;            this.order = order;&#10;            this.itemCount = itemCount;&#10;            this.totalValue = totalValue;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package controller;&#13;&#10;&#13;&#10;import business.OrderBusiness;&#13;&#10;import entity.Order;&#13;&#10;import entity.OrderItems;&#13;&#10;import dto.OrderItemsDTO;&#13;&#10;import dto.AddressDTO;&#13;&#10;import io.javalin.http.Context;&#13;&#10;import com.fasterxml.jackson.databind.JsonNode;&#13;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#13;&#10;&#13;&#10;import java.util.List;&#13;&#10;import java.util.ArrayList;&#13;&#10;&#13;&#10;public class OrderHttpController {&#13;&#10;    private OrderBusiness orderBusiness;&#13;&#10;    private ObjectMapper objectMapper;&#13;&#10;&#13;&#10;    public OrderHttpController(OrderBusiness orderBusiness) {&#13;&#10;        this.orderBusiness = orderBusiness;&#13;&#10;        this.objectMapper = new ObjectMapper();&#13;&#10;    }&#13;&#10;&#13;&#10;    // CREATE - POST /orders&#13;&#10;    public void createOrder(Context ctx) {&#13;&#10;        try {&#13;&#10;            System.out.println(&quot;[CONTROLLER] Starting order creation request&quot;);&#13;&#10;            JsonNode json = objectMapper.readTree(ctx.body());&#13;&#10;            Integer userId = ctx.attribute(&quot;userId&quot;); // From authentication middleware&#13;&#10;&#13;&#10;            if (userId == null) {&#13;&#10;                ctx.status(401).json(new ErrorResponse(&quot;Usuário não autenticado&quot;));&#13;&#10;                return;&#13;&#10;            }&#13;&#10;            System.out.println(&quot;[CONTROLLER] User ID from token: &quot; + userId);&#13;&#10;&#13;&#10;            // Parse address (either new address data or existing address ID)&#13;&#10;            AddressDTO addressDTO = null;&#13;&#10;            Integer existingAddressId = null;&#13;&#10;&#13;&#10;            if (json.has(&quot;addressId&quot;) &amp;&amp; !json.get(&quot;addressId&quot;).isNull()) {&#13;&#10;                existingAddressId = json.get(&quot;addressId&quot;).asInt();&#13;&#10;                System.out.println(&quot;[CONTROLLER] Using existing address ID: &quot; + existingAddressId);&#13;&#10;            } else if (json.has(&quot;address&quot;)) {&#13;&#10;                JsonNode addressNode = json.get(&quot;address&quot;);&#13;&#10;                if (addressNode.get(&quot;street&quot;) == null || addressNode.get(&quot;number&quot;) == null ||&#13;&#10;                    addressNode.get(&quot;neighborhood&quot;) == null || addressNode.get(&quot;zipCode&quot;) == null ||&#13;&#10;                    addressNode.get(&quot;city&quot;) == null || addressNode.get(&quot;state&quot;) == null) {&#13;&#10;                    ctx.status(400).json(new ErrorResponse(&quot;Campos obrigatórios do endereço: street, number, neighborhood, zipCode, city, state&quot;));&#13;&#10;                    return;&#13;&#10;                }&#13;&#10;                addressDTO = new AddressDTO(&#13;&#10;                    addressNode.get(&quot;street&quot;).asText(),&#13;&#10;                    addressNode.get(&quot;number&quot;).asText(),&#13;&#10;                    addressNode.get(&quot;neighborhood&quot;).asText(),&#13;&#10;                    addressNode.get(&quot;zipCode&quot;).asText(),&#13;&#10;                    addressNode.has(&quot;complement&quot;) ? addressNode.get(&quot;complement&quot;).asText() : &quot;&quot;,&#13;&#10;                    addressNode.get(&quot;city&quot;).asText(),&#13;&#10;                    addressNode.get(&quot;state&quot;).asText()&#13;&#10;                );&#13;&#10;                System.out.println(&quot;[CONTROLLER] Creating new address&quot;);&#13;&#10;            } else {&#13;&#10;                ctx.status(400).json(new ErrorResponse(&quot;É necessário fornecer 'addressId' ou dados completos do 'address'&quot;));&#13;&#10;                return;&#13;&#10;            }&#13;&#10;&#13;&#10;            // Parse order items&#13;&#10;            if (!json.has(&quot;items&quot;) || !json.get(&quot;items&quot;).isArray()) {&#13;&#10;                ctx.status(400).json(new ErrorResponse(&quot;Campo 'items' é obrigatório e deve ser um array&quot;));&#13;&#10;                return;&#13;&#10;            }&#13;&#10;&#13;&#10;            List&lt;OrderItemsDTO&gt; orderItems = new ArrayList&lt;&gt;();&#13;&#10;            for (JsonNode itemNode : json.get(&quot;items&quot;)) {&#13;&#10;                if (itemNode.get(&quot;productId&quot;) == null || itemNode.get(&quot;amount&quot;) == null) {&#13;&#10;                    ctx.status(400).json(new ErrorResponse(&quot;Cada item deve conter: productId, amount&quot;));&#13;&#10;                    return;&#13;&#10;                }&#13;&#10;&#13;&#10;                OrderItemsDTO item = new OrderItemsDTO(&#13;&#10;                    itemNode.get(&quot;productId&quot;).asInt(),&#13;&#10;                    itemNode.get(&quot;amount&quot;).asInt()&#13;&#10;                );&#13;&#10;                orderItems.add(item);&#13;&#10;            }&#13;&#10;            System.out.println(&quot;[CONTROLLER] Parsed &quot; + orderItems.size() + &quot; order items&quot;);&#13;&#10;&#13;&#10;            // Create order&#13;&#10;            System.out.println(&quot;[CONTROLLER] Calling business layer to create order&quot;);&#13;&#10;            Order order = orderBusiness.createOrder(userId, addressDTO, existingAddressId, orderItems);&#13;&#10;            System.out.println(&quot;[CONTROLLER] Order created with ID: &quot; + order.getId());&#13;&#10;&#13;&#10;            // Get order items to include in response&#13;&#10;            System.out.println(&quot;[CONTROLLER] Getting order items for response&quot;);&#13;&#10;            List&lt;OrderItems&gt; createdItems = orderBusiness.getOrderItems(order.getId());&#13;&#10;            System.out.println(&quot;[CONTROLLER] Found &quot; + createdItems.size() + &quot; created items&quot;);&#13;&#10;&#13;&#10;            System.out.println(&quot;[CONTROLLER] Calculating order total&quot;);&#13;&#10;            double totalValue = orderBusiness.calculateOrderTotal(order.getId());&#13;&#10;            System.out.println(&quot;[CONTROLLER] Total calculated: &quot; + totalValue);&#13;&#10;&#13;&#10;            OrderResponse response = new OrderResponse(order, createdItems, totalValue);&#13;&#10;            ctx.status(201).json(response);&#13;&#10;            System.out.println(&quot;[CONTROLLER] Order creation completed successfully&quot;);&#13;&#10;&#13;&#10;        } catch (Exception e) {&#13;&#10;            System.err.println(&quot;[CONTROLLER] Error creating order: &quot; + e.getMessage());&#13;&#10;            e.printStackTrace();&#13;&#10;            ctx.status(400).json(new ErrorResponse(&quot;Erro ao criar pedido: &quot; + e.getMessage()));&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // UPDATE - PUT /orders/{id}&#13;&#10;    public void updateOrder(Context ctx) {&#13;&#10;        try {&#13;&#10;            int orderId = Integer.parseInt(ctx.pathParam(&quot;id&quot;));&#13;&#10;            JsonNode json = objectMapper.readTree(ctx.body());&#13;&#10;&#13;&#10;            String orderStatus = json.has(&quot;orderStatus&quot;) ? json.get(&quot;orderStatus&quot;).asText() : null;&#13;&#10;&#13;&#10;            // For backward compatibility, still accept old status fields but ignore them&#13;&#10;            if (json.has(&quot;paymentStatus&quot;) || json.has(&quot;shippingStatus&quot;)) {&#13;&#10;                System.out.println(&quot;[ORDER_CONTROLLER] Warning: paymentStatus and shippingStatus are deprecated, use orderStatus only&quot;);&#13;&#10;            }&#13;&#10;&#13;&#10;            Order updatedOrder = orderBusiness.updateOrderStatus(orderId, orderStatus);&#13;&#10;&#13;&#10;            List&lt;OrderItems&gt; orderItems = orderBusiness.getOrderItems(orderId);&#13;&#10;            double totalValue = orderBusiness.calculateOrderTotal(orderId);&#13;&#10;&#13;&#10;            OrderResponse response = new OrderResponse(updatedOrder, orderItems, totalValue);&#13;&#10;            ctx.json(response);&#13;&#10;&#13;&#10;        } catch (NumberFormatException e) {&#13;&#10;            ctx.status(400).json(new ErrorResponse(&quot;ID do pedido inválido&quot;));&#13;&#10;        } catch (Exception e) {&#13;&#10;            ctx.status(400).json(new ErrorResponse(&quot;Erro ao atualizar pedido: &quot; + e.getMessage()));&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // LIST BY USER - GET /orders (uses authenticated user)&#13;&#10;    public void listOrdersByUser(Context ctx) {&#13;&#10;        try {&#13;&#10;            Integer userId = ctx.attribute(&quot;userId&quot;); // From authentication middleware&#13;&#10;&#13;&#10;            List&lt;Order&gt; orders = orderBusiness.getOrdersByUserId(userId);&#13;&#10;            List&lt;OrderSummary&gt; orderSummaries = new ArrayList&lt;&gt;();&#13;&#10;&#13;&#10;            for (Order order : orders) {&#13;&#10;                List&lt;OrderItems&gt; items = orderBusiness.getOrderItems(order.getId());&#13;&#10;                double totalValue = orderBusiness.calculateOrderTotal(order.getId());&#13;&#10;                orderSummaries.add(new OrderSummary(order, items.size(), totalValue));&#13;&#10;            }&#13;&#10;&#13;&#10;            ctx.json(orderSummaries);&#13;&#10;&#13;&#10;        } catch (Exception e) {&#13;&#10;            ctx.status(500).json(new ErrorResponse(&quot;Erro ao buscar pedidos: &quot; + e.getMessage()));&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // LIST BY USER ID - GET /users/{userId}/orders (for admin or user accessing their own orders)&#13;&#10;    public void listOrdersByUserId(Context ctx) {&#13;&#10;        try {&#13;&#10;            Integer currentUserId = ctx.attribute(&quot;userId&quot;); // From authentication middleware&#13;&#10;            int requestedUserId = Integer.parseInt(ctx.pathParam(&quot;userId&quot;));&#13;&#10;&#13;&#10;            // Simple authorization - users can only see their own orders&#13;&#10;            if (!currentUserId.equals(requestedUserId)) {&#13;&#10;                ctx.status(403).json(new ErrorResponse(&quot;Acesso negado&quot;));&#13;&#10;                return;&#13;&#10;            }&#13;&#10;&#13;&#10;            List&lt;Order&gt; orders = orderBusiness.getOrdersByUserId(requestedUserId);&#13;&#10;            List&lt;OrderSummary&gt; orderSummaries = new ArrayList&lt;&gt;();&#13;&#10;&#13;&#10;            for (Order order : orders) {&#13;&#10;                List&lt;OrderItems&gt; items = orderBusiness.getOrderItems(order.getId());&#13;&#10;                double totalValue = orderBusiness.calculateOrderTotal(order.getId());&#13;&#10;                orderSummaries.add(new OrderSummary(order, items.size(), totalValue));&#13;&#10;            }&#13;&#10;&#13;&#10;            ctx.json(orderSummaries);&#13;&#10;&#13;&#10;        } catch (NumberFormatException e) {&#13;&#10;            ctx.status(400).json(new ErrorResponse(&quot;ID do usuário inválido&quot;));&#13;&#10;        } catch (Exception e) {&#13;&#10;            ctx.status(500).json(new ErrorResponse(&quot;Erro ao buscar pedidos: &quot; + e.getMessage()));&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // CANCEL - DELETE /orders/{id}&#13;&#10;    public void cancelOrder(Context ctx) {&#13;&#10;        try {&#13;&#10;            int orderId = Integer.parseInt(ctx.pathParam(&quot;id&quot;));&#13;&#10;            Integer userId = ctx.attribute(&quot;userId&quot;); // From authentication middleware&#13;&#10;&#13;&#10;            // Verify order belongs to user&#13;&#10;            Order order = orderBusiness.getOrderById(orderId);&#13;&#10;            if (order == null) {&#13;&#10;                ctx.status(404).json(new ErrorResponse(&quot;Pedido não encontrado&quot;));&#13;&#10;                return;&#13;&#10;            }&#13;&#10;&#13;&#10;            if (!userId.equals(order.getUser().getId())) {&#13;&#10;                ctx.status(403).json(new ErrorResponse(&quot;Acesso negado&quot;));&#13;&#10;                return;&#13;&#10;            }&#13;&#10;&#13;&#10;            orderBusiness.cancelOrder(orderId);&#13;&#10;            ctx.json(new SuccessResponse(&quot;Pedido cancelado com sucesso&quot;));&#13;&#10;&#13;&#10;        } catch (NumberFormatException e) {&#13;&#10;            ctx.status(400).json(new ErrorResponse(&quot;ID do pedido inválido&quot;));&#13;&#10;        } catch (Exception e) {&#13;&#10;            ctx.status(400).json(new ErrorResponse(&quot;Erro ao cancelar pedido: &quot; + e.getMessage()));&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // GET ORDER BY ID - GET /orders/{id}&#13;&#10;    public void getOrderById(Context ctx) {&#13;&#10;        try {&#13;&#10;            int orderId = Integer.parseInt(ctx.pathParam(&quot;id&quot;));&#13;&#10;            Integer userId = ctx.attribute(&quot;userId&quot;); // From authentication middleware&#13;&#10;&#13;&#10;            Order order = orderBusiness.getOrderById(orderId);&#13;&#10;            if (order == null) {&#13;&#10;                ctx.status(404).json(new ErrorResponse(&quot;Pedido não encontrado&quot;));&#13;&#10;                return;&#13;&#10;            }&#13;&#10;&#13;&#10;            // Verify order belongs to user&#13;&#10;            if (!userId.equals(order.getUser().getId())) {&#13;&#10;                ctx.status(403).json(new ErrorResponse(&quot;Acesso negado&quot;));&#13;&#10;                return;&#13;&#10;            }&#13;&#10;&#13;&#10;            // Get detailed order information&#13;&#10;            CleanOrderResponse response = orderBusiness.getOrderDetailsById(orderId);&#13;&#10;            if (response == null) {&#13;&#10;                ctx.status(404).json(new ErrorResponse(&quot;Detalhes do pedido não encontrados&quot;));&#13;&#10;                return;&#13;&#10;            }&#13;&#10;&#13;&#10;            ctx.json(response);&#13;&#10;&#13;&#10;        } catch (NumberFormatException e) {&#13;&#10;            ctx.status(400).json(new ErrorResponse(&quot;ID do pedido inválido&quot;));&#13;&#10;        } catch (Exception e) {&#13;&#10;            ctx.status(500).json(new ErrorResponse(&quot;Erro ao buscar pedido: &quot; + e.getMessage()));&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Response classes&#13;&#10;    private static class ErrorResponse {&#13;&#10;        public String message;&#13;&#10;        public ErrorResponse(String message) {&#13;&#10;            this.message = message;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private static class SuccessResponse {&#13;&#10;        public String message;&#13;&#10;        public SuccessResponse(String message) {&#13;&#10;            this.message = message;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private static class OrderResponse {&#13;&#10;        public Order order;&#13;&#10;        public List&lt;OrderItems&gt; items;&#13;&#10;        public double totalValue;&#13;&#10;        public OrderResponse(Order order, List&lt;OrderItems&gt; items, double totalValue) {&#13;&#10;            this.order = order;&#13;&#10;            this.items = items;&#13;&#10;            this.totalValue = totalValue;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private static class OrderSummary {&#13;&#10;        public Order order;&#13;&#10;        public int itemCount;&#13;&#10;        public double totalValue;&#13;&#10;        public OrderSummary(Order order, int itemCount, double totalValue) {&#13;&#10;            this.order = order;&#13;&#10;            this.itemCount = itemCount;&#13;&#10;            this.totalValue = totalValue;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Clean response classes without circular references&#13;&#10;    public static class CleanOrderResponse {&#13;&#10;        public CleanOrder order;&#13;&#10;        public List&lt;CleanOrderItem&gt; items;&#13;&#10;        public double totalValue;&#13;&#10;&#13;&#10;        public CleanOrderResponse(CleanOrder order, List&lt;CleanOrderItem&gt; items, double totalValue) {&#13;&#10;            this.order = order;&#13;&#10;            this.items = items;&#13;&#10;            this.totalValue = totalValue;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public static class CleanOrder {&#13;&#10;        public int id;&#13;&#10;        public CleanUser user;&#13;&#10;        public CleanAddress address;&#13;&#10;        public String orderStatus;&#13;&#10;        public long createdAt;&#13;&#10;        public long updatedAt;&#13;&#10;&#13;&#10;        public CleanOrder(int id, CleanUser user, CleanAddress address, String orderStatus, long createdAt, long updatedAt) {&#13;&#10;            this.id = id;&#13;&#10;            this.user = user;&#13;&#10;            this.address = address;&#13;&#10;            this.orderStatus = orderStatus;&#13;&#10;            this.createdAt = createdAt;&#13;&#10;            this.updatedAt = updatedAt;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public static class CleanUser {&#13;&#10;        public int id;&#13;&#10;        public String name;&#13;&#10;        public String email;&#13;&#10;        public String document;&#13;&#10;&#13;&#10;        public CleanUser(int id, String name, String email, String document) {&#13;&#10;            this.id = id;&#13;&#10;            this.name = name;&#13;&#10;            this.email = email;&#13;&#10;            this.document = document;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public static class CleanAddress {&#13;&#10;        public int id;&#13;&#10;        public String street;&#13;&#10;        public String number;&#13;&#10;        public String neighborhood;&#13;&#10;        public String zipCode;&#13;&#10;        public String complement;&#13;&#10;        public String city;&#13;&#10;        public String state;&#13;&#10;&#13;&#10;        public CleanAddress(int id, String street, String number, String neighborhood, String zipCode, String complement, String city, String state) {&#13;&#10;            this.id = id;&#13;&#10;            this.street = street;&#13;&#10;            this.number = number;&#13;&#10;            this.neighborhood = neighborhood;&#13;&#10;            this.zipCode = zipCode;&#13;&#10;            this.complement = complement;&#13;&#10;            this.city = city;&#13;&#10;            this.state = state;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public static class CleanOrderItem {&#13;&#10;        public int id;&#13;&#10;        public CleanProduct product;&#13;&#10;        public int amount;&#13;&#10;        public double value;&#13;&#10;        public double totalValue;&#13;&#10;&#13;&#10;        public CleanOrderItem(int id, CleanProduct product, int amount, double value, double totalValue) {&#13;&#10;            this.id = id;&#13;&#10;            this.product = product;&#13;&#10;            this.amount = amount;&#13;&#10;            this.value = value;&#13;&#10;            this.totalValue = totalValue;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public static class CleanProduct {&#13;&#10;        public int id;&#13;&#10;        public String name;&#13;&#10;        public String description;&#13;&#10;        public int availableAmount;&#13;&#10;        public String image;&#13;&#10;        public String deletedAt;&#13;&#10;        public boolean deleted;&#13;&#10;&#13;&#10;        public CleanProduct(int id, String name, String description, int availableAmount, String image, String deletedAt, boolean deleted) {&#13;&#10;            this.id = id;&#13;&#10;            this.name = name;&#13;&#10;            this.description = description;&#13;&#10;            this.availableAmount = availableAmount;&#13;&#10;            this.image = image;&#13;&#10;            this.deletedAt = deletedAt;&#13;&#10;            this.deleted = deleted;&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/model/User.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/model/User.java" />
              <option name="updatedContent" value="package model;&#10;&#10;public class User {&#10;    private int id;&#10;    private String name;&#10;    private String email;&#10;    private String password;&#10;    private String document;&#10;&#10;    public User(int id, String name, String email, String password, String document) {&#10;        this.id = id;&#10;        this.name = name;&#10;        this.email = email;&#10;        this.password = password;&#10;        this.document = document;&#10;    }&#10;    public int getId() { return id; }&#10;    public String getName() { return name; }&#10;    public String getEmail() { return email; }&#10;    public String getPassword() { return password; }&#10;    public String getDocument() { return document; }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/model/UserModel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/model/UserModel.java" />
              <option name="originalContent" value="package model;&#10;&#10;import java.io.*;&#10;import java.util.*;&#10;&#10;public class UserModel {&#10;    private static final String FILE_NAME = &quot;users.csv&quot;;&#10;&#10;    public static void save(User user) throws IOException {&#10;        boolean fileExists = new File(FILE_NAME).exists();&#10;        try (FileWriter fw = new FileWriter(FILE_NAME, true);&#10;             BufferedWriter bw = new BufferedWriter(fw);&#10;             PrintWriter out = new PrintWriter(bw)) {&#10;            if (!fileExists) {&#10;                out.println(&quot;id,name,email,password,document&quot;);&#10;            }&#10;            out.printf(&quot;%d,%s,%s,%s,%s\n&quot;, user.getId(), user.getName(), user.getEmail(), user.getPassword(), user.getDocument());&#10;        }&#10;    }&#10;&#10;    public static List&lt;User&gt; findAll() throws IOException {&#10;        List&lt;User&gt; users = new ArrayList&lt;&gt;();&#10;        try (BufferedReader br = new BufferedReader(new FileReader(FILE_NAME))) {&#10;            String line = br.readLine(); // header&#10;            while ((line = br.readLine()) != null) {&#10;                String[] parts = line.split(&quot;,&quot;);&#10;                if (parts.length == 5) {&#10;                    users.add(new User(&#10;                        Integer.parseInt(parts[0]),&#10;                        parts[1], parts[2], parts[3], parts[4]&#10;                    ));&#10;                }&#10;            }&#10;        }&#10;        return users;&#10;    }&#10;&#10;    public static User findByEmail(String email) throws IOException {&#10;        for (User user : findAll()) {&#10;            if (user.getEmail().equalsIgnoreCase(email)) return user;&#10;        }&#10;        return null;&#10;    }&#10;&#10;    public static int getNextId() throws IOException {&#10;        List&lt;User&gt; users = findAll();&#10;        return users.isEmpty() ? 1 : users.get(users.size() - 1).getId() + 1;&#10;    }&#10;&#10;    public static class User {&#10;        private int id;&#10;        private String name;&#10;        private String email;&#10;        private String password;&#10;        private String document;&#10;&#10;        public User(int id, String name, String email, String password, String document) {&#10;            this.id = id;&#10;            this.name = name;&#10;            this.email = email;&#10;            this.password = password;&#10;            this.document = document;&#10;        }&#10;        public int getId() { return id; }&#10;        public String getName() { return name; }&#10;        public String getEmail() { return email; }&#10;        public String getPassword() { return password; }&#10;        public String getDocument() { return document; }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package model;&#10;&#10;import java.io.*;&#10;import java.util.*;&#10;&#10;public class UserRepository {&#10;    private static final String FILE_NAME = &quot;users.csv&quot;;&#10;&#10;    public static void save(User user) throws IOException {&#10;        boolean fileExists = new File(FILE_NAME).exists();&#10;        try (FileWriter fw = new FileWriter(FILE_NAME, true);&#10;             BufferedWriter bw = new BufferedWriter(fw);&#10;             PrintWriter out = new PrintWriter(bw)) {&#10;            if (!fileExists) {&#10;                out.println(&quot;id,name,email,password,document&quot;);&#10;            }&#10;            out.printf(&quot;%d,%s,%s,%s,%s\n&quot;, user.getId(), user.getName(), user.getEmail(), user.getPassword(), user.getDocument());&#10;        }&#10;    }&#10;&#10;    public static List&lt;User&gt; findAll() throws IOException {&#10;        List&lt;User&gt; users = new ArrayList&lt;&gt;();&#10;        try (BufferedReader br = new BufferedReader(new FileReader(FILE_NAME))) {&#10;            String line = br.readLine(); // header&#10;            while ((line = br.readLine()) != null) {&#10;                String[] parts = line.split(&quot;,&quot;);&#10;                if (parts.length == 5) {&#10;                    users.add(new User(&#10;                        Integer.parseInt(parts[0]),&#10;                        parts[1], parts[2], parts[3], parts[4]&#10;                    ));&#10;                }&#10;            }&#10;        }&#10;        return users;&#10;    }&#10;&#10;    public static User findByEmail(String email) throws IOException {&#10;        for (User user : findAll()) {&#10;            if (user.getEmail().equalsIgnoreCase(email)) return user;&#10;        }&#10;        return null;&#10;    }&#10;&#10;    public static int getNextId() throws IOException {&#10;        List&lt;User&gt; users = findAll();&#10;        return users.isEmpty() ? 1 : users.get(users.size() - 1).getId() + 1;&#10;    }&#10;&#10;    public static class User {&#10;        private int id;&#10;        private String name;&#10;        private String email;&#10;        private String password;&#10;        private String document;&#10;&#10;        public User(int id, String name, String email, String password, String document) {&#10;            this.id = id;&#10;            this.name = name;&#10;            this.email = email;&#10;            this.password = password;&#10;            this.document = document;&#10;        }&#10;        public int getId() { return id; }&#10;        public String getName() { return name; }&#10;        public String getEmail() { return email; }&#10;        public String getPassword() { return password; }&#10;        public String getDocument() { return document; }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/models/Model.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/models/Model.java" />
              <option name="originalContent" value="package models;&#10;&#10;import java.io.*;&#10;import java.util.*;&#10;import java.util.function.Function;&#10;&#10;public abstract class Model&lt;T&gt; {&#10;    protected String fileName;&#10;    protected Function&lt;String[], T&gt; mapper;&#10;&#10;    public Model(String fileName, Function&lt;String[], T&gt; mapper) {&#10;        this.fileName = fileName;&#10;        this.mapper = mapper;&#10;    }&#10;&#10;    // Cria um novo registro no arquivo CSV&#10;    public void create(String[] values) throws IOException {&#10;        boolean fileExists = new File(fileName).exists();&#10;        try (FileWriter fw = new FileWriter(fileName, true);&#10;             BufferedWriter bw = new BufferedWriter(fw);&#10;             PrintWriter out = new PrintWriter(bw)) {&#10;            if (!fileExists) {&#10;                // Não escreve header, pois é abstrato&#10;            }&#10;            out.println(String.join(&quot;,&quot;, values));&#10;        }&#10;    }&#10;&#10;    // Busca todos os registros do arquivo CSV&#10;    public List&lt;T&gt; find() throws IOException {&#10;        List&lt;T&gt; results = new ArrayList&lt;&gt;();&#10;        try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {&#10;            String line;&#10;            while ((line = br.readLine()) != null) {&#10;                String[] parts = line.split(&quot;,&quot;);&#10;                T obj = mapper.apply(parts);&#10;                if (obj != null) {&#10;                    results.add(obj);&#10;                }&#10;            }&#10;        }&#10;        return results;&#10;    }&#10;&#10;    // Busca registros que contenham todos os parâmetros informados&#10;    public List&lt;T&gt; find(Map&lt;Integer, String&gt; params) throws IOException {&#10;        List&lt;T&gt; results = new ArrayList&lt;&gt;();&#10;        try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {&#10;            String line;&#10;            while ((line = br.readLine()) != null) {&#10;                String[] parts = line.split(&quot;,&quot;);&#10;                boolean match = true;&#10;                for (Map.Entry&lt;Integer, String&gt; entry : params.entrySet()) {&#10;                    int idx = entry.getKey();&#10;                    if (idx &gt;= parts.length || !parts[idx].equals(entry.getValue())) {&#10;                        match = false;&#10;                        break;&#10;                    }&#10;                }&#10;                if (match) {&#10;                    T obj = mapper.apply(parts);&#10;                    if (obj != null) {&#10;                        results.add(obj);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return results;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package models;&#10;&#10;import java.io.*;&#10;import java.util.*;&#10;import java.util.function.Function;&#10;&#10;public abstract class Model&lt;T&gt; {&#10;    protected String fileName;&#10;    protected Function&lt;String[], T&gt; mapper;&#10;&#10;    public Model(String fileName, Function&lt;String[], T&gt; mapper) {&#10;        this.fileName = fileName;&#10;        this.mapper = mapper;&#10;    }&#10;&#10;    // Cria um novo registro no arquivo CSV usando genéricos&#10;    public void create(T obj, Function&lt;T, String[]&gt; toArray) throws IOException {&#10;        String[] values = toArray.apply(obj);&#10;        boolean fileExists = new File(fileName).exists();&#10;        try (FileWriter fw = new FileWriter(fileName, true);&#10;             BufferedWriter bw = new BufferedWriter(fw);&#10;             PrintWriter out = new PrintWriter(bw)) {&#10;            if (!fileExists) {&#10;                // Não escreve header, pois é abstrato&#10;            }&#10;            out.println(String.join(&quot;,&quot;, values));&#10;        }&#10;    }&#10;&#10;    // Busca todos os registros do arquivo CSV&#10;    public List&lt;T&gt; find() throws IOException {&#10;        List&lt;T&gt; results = new ArrayList&lt;&gt;();&#10;        try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {&#10;            String line;&#10;            while ((line = br.readLine()) != null) {&#10;                String[] parts = line.split(&quot;,&quot;);&#10;                T obj = mapper.apply(parts);&#10;                if (obj != null) {&#10;                    results.add(obj);&#10;                }&#10;            }&#10;        }&#10;        return results;&#10;    }&#10;&#10;    // Busca registros que contenham todos os parâmetros informados&#10;    public List&lt;T&gt; find(Map&lt;Integer, String&gt; params) throws IOException {&#10;        List&lt;T&gt; results = new ArrayList&lt;&gt;();&#10;        try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {&#10;            String line;&#10;            while ((line = br.readLine()) != null) {&#10;                String[] parts = line.split(&quot;,&quot;);&#10;                boolean match = true;&#10;                for (Map.Entry&lt;Integer, String&gt; entry : params.entrySet()) {&#10;                    int idx = entry.getKey();&#10;                    if (idx &gt;= parts.length || !parts[idx].equals(entry.getValue())) {&#10;                        match = false;&#10;                        break;&#10;                    }&#10;                }&#10;                if (match) {&#10;                    T obj = mapper.apply(parts);&#10;                    if (obj != null) {&#10;                        results.add(obj);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return results;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/models/UserModel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/models/UserModel.java" />
              <option name="updatedContent" value="package models;&#10;&#10;import java.io.*;&#10;import java.util.*;&#10;&#10;public class UserModel extends Model {&#10;    public UserModel(String fileName) {&#10;        super(fileName);&#10;    }&#10;&#10;    public void create(int id, String name, String email, String password, String document) throws IOException {&#10;        String[] values = {String.valueOf(id), name, email, password, document};&#10;        super.create(values);&#10;    }&#10;&#10;    public List&lt;User&gt; find() throws IOException {&#10;        List&lt;User&gt; users = new ArrayList&lt;&gt;();&#10;        List&lt;String[]&gt; rows = super.find();&#10;        for (String[] row : rows) {&#10;            if (row.length == 5) {&#10;                users.add(new User(&#10;                    Integer.parseInt(row[0]),&#10;                    row[1], row[2], row[3], row[4]&#10;                ));&#10;            }&#10;        }&#10;        return users;&#10;    }&#10;&#10;    public List&lt;User&gt; find(Map&lt;Integer, String&gt; params) throws IOException {&#10;        List&lt;User&gt; users = new ArrayList&lt;&gt;();&#10;        List&lt;String[]&gt; rows = super.find(params);&#10;        for (String[] row : rows) {&#10;            if (row.length == 5) {&#10;                users.add(new User(&#10;                    Integer.parseInt(row[0]),&#10;                    row[1], row[2], row[3], row[4]&#10;                ));&#10;            }&#10;        }&#10;        return users;&#10;    }&#10;&#10;    public static class User {&#10;        private int id;&#10;        private String name;&#10;        private String email;&#10;        private String password;&#10;        private String document;&#10;&#10;        public User(int id, String name, String email, String password, String document) {&#10;            this.id = id;&#10;            this.name = name;&#10;            this.email = email;&#10;            this.password = password;&#10;            this.document = document;&#10;        }&#10;&#10;        public int getId() { return id; }&#10;        public String getName() { return name; }&#10;        public String getEmail() { return email; }&#10;        public String getPassword() { return password; }&#10;        public String getDocument() { return document; }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>